#!/usr/bin/python3
# encoding: utf-8

import sys
import os
import shutil
import argparse
from random import shuffle
import mimetypes
from gi import require_version
require_version('Gtk', '3.0')
from gi.repository import GLib, Gtk, Gdk, GdkPixbuf
from PIL import Image, ImageEnhance
from subprocess import call, Popen, PIPE
# Settings
sys.path.append(os.path.join(os.path.expanduser("~"), ".vimiv"))
sys.path.append("/etc")
import vimivrc as settings


class Vimiv(Gtk.Window):

    def __init__(self):
        # The configruations from vimivrc
        self.fullscreen = settings.start_fullscreen
        self.slideshow = settings.start_slideshow
        self.slideshow_delay = settings.slideshow_delay
        self.shuffle = settings.shuffle
        self.sbar = settings.display_bar
        self.zoom_lock = settings.zoom_lock
        self.thumbnail_toggled = settings.thumbnail_toggled
        self.library_toggled = False
        self.tiling_wm = settings.tiling_wm
        self.geometry = settings.geometry
        self.recursive = settings.recursive
        self.animation_toggled = False
        self.size = (100, 100)  # necessary for checks, start value for til_wm

        self.paths = []
        self.marked = []

        self.thumbsize = settings.thumbsize

        self.binds = (
            (settings.key_quit, self.quit),
            (settings.key_animation_toggle, self.animation_toggle),

            (settings.key_fullscreen_toggle, self.toggle_fullscreen),
            (settings.key_statusbar_toggle, self.toggle_statusbar),
            (settings.key_slideshow_toggle, self.toggle_slideshow),
            (settings.key_zoomlock_toggle, self.toggle_zoom_lock),
            (settings.key_thumbnail_toggle, self.thumbnail_toggle,
             self.thumbnail_toggled),
            (settings.key_library_toggle, self.library_toggle),
            (settings.key_move_up, self.move_up),

            # if True, scroll in the horizontal direction.
            (settings.key_scroll_left, self.scroll,
             Gtk.ScrollType.STEP_BACKWARD, True),
            (settings.key_scroll_down, self.scroll,
             Gtk.ScrollType.STEP_FORWARD, False),
            (settings.key_scroll_up, self.scroll,
             Gtk.ScrollType.STEP_BACKWARD, False),
            (settings.key_scroll_right, self.scroll,
             Gtk.ScrollType.STEP_FORWARD, True),

            (settings.key_scroll_left_page, self.scroll,
             Gtk.ScrollType.START, True),
            (settings.key_scroll_down_page, self.scroll,
             Gtk.ScrollType.END, False),
            (settings.key_scroll_up_page, self.scroll,
             Gtk.ScrollType.START, False),
            (settings.key_scroll_right_page, self.scroll,
             Gtk.ScrollType.END, True),

            (settings.key_zoom_out, self.zoom_delta, -.25),
            (settings.key_zoom_in, self.zoom_delta, +.25),
            (settings.key_fit, self.zoom_to, 0),
            (settings.key_fit_horiz, self.zoom_to, 0, True, False),
            (settings.key_fit_vert, self.zoom_to, 0, False, True),

            (settings.key_next_image, self.move_index, +1),
            (settings.key_prev_image, self.move_index, -1),
            (settings.key_first_image, self.move_pos, 1),
            (settings.key_last_image, self.move_pos, "max"),

            (settings.key_mark, self.mark),

            (settings.key_rotate_clock, self.rotate, 3),
            (settings.key_rotate_cclock, self.rotate, 1),
            (settings.key_fliph, self.flip, True),
            (settings.key_flipv, self.flip, False),
            (settings.key_delete, self.delete, 0),
            (settings.key_edit, self.manipulate_toggle),
            )

        self.popup_val = False
        Gtk.Window.__init__(self)

    def toggle_zoom_lock(self):
        self.zoom_lock = not self.zoom_lock

    def delete(self, delta=0):
        current = self.paths[self.index]
        self.paths.remove(current)
        if current in self.marked:
            self.marked.remove(current)
        if os.path.exists(current):
            deldir = os.path.join(os.path.expanduser("~"), ".vimiv/Trash")
            if not os.path.isdir(deldir):
                os.mkdir(deldir)
            # Check if there is already a file with that name in the trash
            delfile = deldir + os.path.basename(current)
            if os.path.exists(delfile):
                backnum = 1
                while True:
                    ndelfile = delfile+"."+str(backnum)
                    if not os.path.exists(ndelfile):
                        shutil.move(delfile, ndelfile)
                        break
                    backnum += 1
            shutil.move(current, deldir)
        if len(self.paths) == 0:
            self.quit()
        else:
            self.move_index(delta)

    def quit(self):
        for pos in self.marked:
            print(pos)

        Gtk.main_quit()

    def scroll(self, scrolltype, horizontal):
        """ Scroll the correct object """
        if self.library_toggled:
            self.library_scroll(scrolltype, horizontal)
        elif self.thumbnail_toggled:
            self.thumbnail_scroll(scrolltype, horizontal)
        else:
            self.scrolled_win.emit('scroll-child', scrolltype, horizontal)

    def library_scroll(self, scrolltype, horizontal):
        """ Scroll the library viewer and select if necessary """
        # Handle the specific keys
        if horizontal:
            if scrolltype == Gtk.ScrollType.STEP_BACKWARD:
                self.move_up()
            else:
                self.file_select(self.treepos, "count", "b")
        else:
            if scrolltype == Gtk.ScrollType.STEP_FORWARD:
                # go down
                self.treepos += 1
                if self.treepos > len(self.filelist):
                    self.treepos = len(self.filelist)
            else:
                # go up
                self.treepos -= 1
                if self.treepos < 0:
                    self.treepos = 0
            path = Gtk.TreePath(self.treepos)
            # col = self.filelist[path][:]
            select = self.treeview.get_selected_rows()
            treeiter = self.filelist.get_iter(path)
            print(1)
            select.select_iter(treeiter)
            print(2)

    def thumbnail_scroll(self, scrolltype, horizontal):
        """ Select thumbnails correctly and scroll """
        # Adjust the scrolling so it moves one thumbnail by one
        Gtk.Adjustment.set_step_increment(
            self.viewport.get_vadjustment(), self.thumbsize[1])
        # Check for the specified thumbnail and handle exceptons
        if scrolltype == Gtk.ScrollType.STEP_BACKWARD and horizontal:
            self.togo[0] -= 1
            if self.togo[0] < 0:
                self.togo[0] = 0
        elif scrolltype == Gtk.ScrollType.STEP_BACKWARD:
            self.togo[0] -= self.columns
            if self.togo[0] < 0:
                self.togo[0] += self.columns
        elif scrolltype == Gtk.ScrollType.STEP_FORWARD and horizontal:
            self.togo[0] += 1
            if self.togo[0] == len(self.paths):
                self.togo[0] -= 1
        else:
            self.togo = [self.togo[0] + self.columns]
            if self.togo[0] >= len(self.paths):
                self.togo[0] -= self.columns
        # Exceptions
        # Move
        path = Gtk.TreePath.new_from_indices(self.togo)
        self.iconview.select_path(path)
        curthing = self.iconview.get_cells()[0]
        self.iconview.set_cursor(path, curthing, False)
        self.scrolled_win.emit('scroll-child', scrolltype, horizontal)

    def toggle_slideshow(self):
        self.slideshow = not self.slideshow
        if self.slideshow:
            self.timer_id = GLib.timeout_add_seconds(self.slideshow_delay,
                                                     self.move_index, 1)
        else:
            GLib.source_remove(self.timer_id)
        self.update_info()

    def err_message(self, id, mes):
        if not self.sbar:
            self.statusbar.push(id, mes)
            self.timer_id = GLib.timeout_add_seconds(1, self.statusbar.pop, id)
        else:
            self.toggle_statusbar()
            self.statusbar.push(id, mes)
            self.timer_id = GLib.timeout_add_seconds(1, self.statusbar.pop, id)
            self.timer_id = GLib.timeout_add_seconds(1, self.toggle_statusbar)

    def toggle_fullscreen(self):
        self.fullscreen = not self.fullscreen

        if self.fullscreen:
            self.win.fullscreen()
            # Save previous window size. Possible since get_size gets old value
            # And this is also the cause for some problems
            # (zoomfactor for fullscreen on non fullscreen window)
            self.Sizes['wSize'] = self.win.get_size()
        else:
            self.win.unfullscreen()
        if not self.zoom_lock:
            self.zoom_percent = self.get_zoom_percent()

        self.update_image()

    def toggle_statusbar(self):
        if not self.sbar:
            Gtk.Widget.hide(self.statusbar)
        else:
            Gtk.Widget.show(self.statusbar)
        self.sbar = not self.sbar

    def rotate(self, cwise):
        try:
            self.pixbufOriginal = self.pixbufOriginal.rotate_simple((90*cwise))

            if not self.zoom_lock:
                self.zoom_percent = self.get_zoom_percent()
            self.update_image()

            im = Image.open(self.paths[self.index])
            if cwise == 3:
                im = im.transpose(Image.ROTATE_270)
            else:
                im = im.transpose(Image.ROTATE_90)
            im.save(self.paths[self.index])

        except:
            err = "Warning: Object cannot be rotated"
            self.err_message(5, err)

    def flip(self, dir):
        try:
            self.pixbufOriginal = self.pixbufOriginal.flip(dir)

            if not self.zoom_lock:
                self.zoom_percent = self.get_zoom_percent()
            self.update_image()

            im = Image.open(self.paths[self.index])
            if dir:
                im = im.transpose(Image.FLIP_LEFT_RIGHT)
            else:
                im = im.transpose(Image.FLIP_TOP_BOTTOM)
            im.save(self.paths[self.index])

        except:
            err = "Warning: Object cannot be flipped"
            self.err_message(6, err)

    def manipulate(self):
        self.popup = Gtk.Window()
        self.popup.set_title("Image Manipulation")
        self.popup.set_border_width(5)
        self.popup.set_default_size(300, 300)
        self.popup.set_role("pop-up")
        self.popup.add_events(Gdk.EventMask.KEY_PRESS_MASK |
                              Gdk.EventMask.POINTER_MOTION_MASK)
        self.popup.connect("key_press_event", self.handle_key_press)
        self.popup.set_icon_name("image-x-generic")

        vbox = Gtk.VBox(spacing=2)

        scale_bri = Gtk.HScale()
        scale_bri.set_range(-127, 127)
        scale_bri.set_size_request(320, 25)
        scale_bri.set_value(0)
        scale_bri.set_digits(0)
        scale_bri.set_increments(1, 10)
        scale_bri.connect("value-changed", self.value_slider, "bri")
        bri_label = Gtk.Label()
        bri_label.set_text("\nBrightness")

        scale_con = Gtk.HScale()
        scale_con.set_range(-127, 127)
        scale_con.set_size_request(320, 25)
        scale_con.set_value(0)
        scale_con.set_digits(0)
        scale_con.set_increments(1, 10)
        scale_con.connect("value-changed", self.value_slider, "con")
        con_label = Gtk.Label()
        con_label.set_text("\nContrast")

        button_yes = Gtk.Button(label="Accept changes")
        button_yes.connect("clicked", self.button_yes_clicked)
        button_no = Gtk.Button(label="Cancel")
        button_no.connect("clicked", self.button_no_clicked)
        button_opt = Gtk.Button(label="Optimize")
        button_opt.connect("clicked", self.button_opt_clicked)

        hbox = Gtk.HBox(spacing=4)
        hbox.add(button_no)
        hbox.add(button_yes)

        vbox.add(bri_label)
        vbox.add(scale_bri)
        vbox.add(con_label)
        vbox.add(scale_con)
        vbox.add(button_opt)
        vbox.add(hbox)

        self.popup.add(vbox)
        self.popup.show_all()

    def manipulate_toggle(self):
        if self.popup_val:
            self.popup_val = False
            self.popup.destroy()
        else:
            self.popup_val = True
            self.manipulate()

    def value_slider(self, w, value):
        val = w.get_value()
        im = Image.open(self.paths[self.index])
        if "edit" not in self.paths[self.index]:
            self.paths[self.index] = self.paths[self.index] + "edit"

        if value == "bri":
            val = (val + 127) / 127
            enh_val = ImageEnhance.Brightness(im)
        elif value == "con":
            val = (val + 127) / 127
            enh_val = ImageEnhance.Contrast(im)

        enh_val.enhance(val).save(self.paths[self.index], "JPEG")

        self.image.clear()
        self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
            self.paths[self.index])
        if self.pixbufOriginal.is_static_image():
            self.pixbufOriginal = self.pixbufOriginal.get_static_image()
            if not self.zoom_lock:
                if not self.fullscreen:
                    self.Sizes['wSize'] = self.win.get_size()
                self.zoom_percent = self.get_zoom_percent()
        else:
            self.zoom_percent = 1
        self.update_image()
        self.paths[self.index] = self.paths[self.index].rstrip("edit")

    def button_yes_clicked(self, widget):
        try:
            shutil.move(self.paths[self.index] + "edit", self.paths[self.index])
        except:
            err = "Error: no changes saved"
            self.err_message(3, err)
        self.manipulate_toggle()

    def button_no_clicked(self, widget):
        try:
            os.remove(self.paths[self.index] + "edit")
            self.paths[self.index] = self.paths[self.index].rstrip("edit")
            self.image.clear()
            self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
                self.paths[self.index])
            if self.pixbufOriginal.is_static_image():
                self.pixbufOriginal = self.pixbufOriginal.get_static_image()
                if not self.zoom_lock:
                    if not self.fullscreen:
                        self.Sizes['wSize'] = self.win.get_size()
                    self.zoom_percent = self.get_zoom_percent()
            else:
                self.zoom_percent = 1
            self.update_image()
        except:
            err = "No file to remove"
            self.err_message(4, err)
        self.manipulate_toggle()

    def button_opt_clicked(self, widget):
        call(["convert", "-contrast", "-auto-gamma", "-auto-level",
              self.paths[self.index], self.paths[self.index] + "edit"])

        self.image.clear()
        self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
            self.paths[self.index] + "edit")
        if self.pixbufOriginal.is_static_image():
            self.pixbufOriginal = self.pixbufOriginal.get_static_image()
            if not self.zoom_lock:
                if not self.fullscreen:
                    self.Sizes['wSize'] = self.win.get_size()
                self.zoom_percent = self.get_zoom_percent()
        else:
            self.zoom_percent = 1
        self.update_image()

    def animation_toggle(self):
        self.animation_toggled = not self.animation_toggled
        self.update_image()

    def thumbnails(self):
        # Size of the thumbnails
        size = self.thumbsize
        imlist = list()

        # thumbnail directory and all thumbnails in there
        thumbdir = os.path.join(os.path.expanduser("~"), ".vimiv/Thumbnails")
        p = Popen(['ls', thumbdir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        thumbnails, err = p.communicate()
        thumbnails = thumbnails.decode(encoding='UTF-8')

        # Create thumbnail directory if necessary
        if not os.path.isdir(thumbdir):
            os.mkdir(thumbdir)

        # Create thumbnails for all images in the path
        for infile in self.paths:
            outfile = infile.split(".")[0] + ".thumbnail" + ".png"
            outfile = outfile.split("/")[-1]
            outfile = os.path.join(thumbdir, outfile)
            # Only if they aren't cached already
            if outfile.split("/")[-1] not in thumbnails:
                try:
                    im = Image.open(infile)
                    im.thumbnail(size)
                    im.save(outfile, "PNG")
                    imlist.append(outfile)
                except:
                    err = "Error: thumbnail creation for " + outfile + " failed"
                    self.err_message(4, err)
            else:
                imlist.append(outfile)

        # Create the liststore and iconview
        liststore = Gtk.ListStore(GdkPixbuf.Pixbuf, str)
        self.iconview = Gtk.IconView.new()
        self.iconview.connect("item-activated", self.iconview_clicked)
        self.iconview.set_model(liststore)
        self.columns = int(self.size[0]/(self.thumbsize[0]+100))
        self.iconview.set_columns(self.columns)
        self.iconview.set_column_spacing(0)
        self.iconview.set_row_spacing(0)
        self.iconview.set_item_width(128)
        self.iconview.set_pixbuf_column(0)
        self.iconview.set_border_width(1)
        self.iconview.set_text_column(1)

        # Add all thumbnails to the liststore
        for thumb in imlist:
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(thumb)
            name = thumb.split("/")[-1].split(".")[0]
            liststore.append([pixbuf, name])

        # Draw the icon view instead of the image
        self.viewport.remove(self.image)
        self.viewport.add(self.iconview)
        # Show the window
        self.iconview.show()
        self.thumbnail_toggled = True
        # Focus the current immage
        self.iconview.grab_focus()
        self.togo = [(self.index) % len(self.paths)]
        curpath = Gtk.TreePath.new_from_indices(self.togo)
        self.iconview.select_path(curpath)
        curthing = self.iconview.get_cells()[0]
        self.iconview.set_cursor(curpath, curthing, False)

    def iconview_clicked(self, w, count):
        self.thumbnail_toggle(self.thumbnail_toggled)
        count = count.get_indices()[0] + 1
        self.move_pos(count)

    def thumbnail_toggle(self, thumbnail_toggled):
        if self.thumbnail_toggled:
            self.viewport.remove(self.iconview)
            self.viewport.add(self.image)
            self.update_image()
            self.win.show()
            self.thumbnail_toggled = False
        else:
            self.thumbnails()
            # ugly workaround (scrolls to the current thumbnail)
            # TODO Improve this
            self.zoom_delta(1)
            self.timer_id = GLib.timeout_add(1, self.scroll_to_thumb)

    def scroll_to_thumb(self):
        scrollamount = int(self.togo[0] / self.columns) * self.thumbsize[1]
        Gtk.Adjustment.set_step_increment(
            self.viewport.get_vadjustment(), scrollamount)
        self.scrolled_win.emit('scroll-child',
                               Gtk.ScrollType.STEP_FORWARD, False)

    def get_zoom_percent(self, zWidth=False, zHeight=False):
        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()
        pboScale = pboWidth / pboHeight

        if self.fullscreen:
            winSize = (self.Sizes['sWidth'], self.Sizes['sHeight'])
            wScale = self.Sizes['sWidth'] / self.Sizes['sHeight']
        else:
            winSize = self.Sizes['wSize']
            wScale = self.Sizes['wSize'][0] / self.Sizes['wSize'][1]

        stickout = zWidth | zHeight
        if pboWidth < winSize[0] and pboHeight < winSize[1] and not stickout:
            return 1
        elif (pboScale < wScale and not stickout) or zHeight:
            return winSize[1] / pboHeight
        else:
            return winSize[0] / pboWidth

    def update_image(self):
        ''' Show the final image '''

        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()

        try:
            pbfWidth = int(pboWidth * self.zoom_percent)
            pbfHeight = int(pboHeight * self.zoom_percent)
            pixbufFinal = self.pixbufOriginal.scale_simple(
                pbfWidth, pbfHeight, GdkPixbuf.InterpType.BILINEAR)
            self.image.set_from_pixbuf(pixbufFinal)
        except:
            if not self.animation_toggled:
                self.image.set_from_animation(self.pixbufOriginal)
            else:
                pixbufFinal = self.pixbufOriginal.get_static_image()
                self.image.set_from_pixbuf(pixbufFinal)

        self.update_info()

    def set_default_window_size(self):
        if self.tiling_wm:
            self.win.resize(self.size[0], self.size[1])
            self.timer_id = GLib.timeout_add(1, self.start_size)
        else:
            try:
                self.size = int(self.geometry.split("x")[0]), \
                    int(self.geometry.split("x")[1])
            except:
                errstring = "Must be a correct geometry in the form of " + \
                    "800x600, falling back to default"
                print(errstring)
                self.size = (800, 600)
            self.win.resize(self.size[0], self.size[1])

        if self.fullscreen:
            self.win.fullscreen()

    def start_size(self):
        if self.win.get_size() == self.size or len(self.paths) == 0:
            return True
        else:
            self.zoom_to(0)
            return False

    def update_info(self):
        name = self.paths[self.index].split("/")
        name = name[-1]
        message = "{0}/{1}   [{3:3.0f}%]   {2: <30} {5: <3} {4: <11}".format(
            self.index+1, len(self.paths), name,
            self.zoom_percent * 100, '[slideshow]' if self.slideshow else '',
            '[*]' if self.paths[self.index] in self.marked else '')
        self.win.set_title("vimiv "+message)
        self.statusbar.push(1, message)

    def zoom_delta(self, delta):
        try:
            self.zoom_percent = self.zoom_percent + delta
            self.update_image()
        except:
            err = "Warning: Object cannot be zoomed"
            self.err_message(7, err)

    def zoom_to(self, percent, zWidth=False, zHeight=False):
        try:
            if not self.fullscreen:
                self.Sizes['wSize'] = self.win.get_size()
            self.zoom_percent = percent if percent else self.get_zoom_percent(
                zWidth,
                zHeight)
            self.update_image()
        except:
            err = "Warning: Object cannot be zoomed"
            self.err_message(7, err)

    def move_index(self, delta):
        self.index = (self.index + delta) % len(self.paths)

        # reshuffle on wrap-around
        if self.shuffle and self.index is 0 and delta > 0:
            shuffle(self.paths)

        path = self.paths[self.index]
        try:
            if not os.path.exists(path):
                print("::Error: Couldn't open", path)
                self.delete()
                return
            else:
                self.pixbufOriginal = GdkPixbuf.PixbufAnimation.new_from_file(
                    path)
            if self.pixbufOriginal.is_static_image():
                self.pixbufOriginal = self.pixbufOriginal.get_static_image()
                if not self.zoom_lock:
                    if not self.fullscreen:
                        self.Sizes['wSize'] = self.win.get_size()
                    self.zoom_percent = self.get_zoom_percent()
            else:
                self.zoom_percent = 1
            self.update_image()

            self.scroll(Gtk.ScrollType.START, False)
            self.scroll(Gtk.ScrollType.START, True)

        except GLib.Error as err:
            print(err)
            self.move_index(1)

        return True  # for the slideshow

    def move_pos(self, pos=1):
        current = (self.index) % len(self.paths)
        max = len(self.paths)
        if pos == "max":
            pos = max
        try:
            current = int(current)
            max = int(max)
        except:
            err = "Warning: Unsupported index"
            self.err_message(8, err)
            return False
        current += 1
        dif = pos - current
        self.move_index(dif)

        return True

    def parse_args(self):
        usage = '%(prog)s [options] [paths ...]'
        parser = argparse.ArgumentParser(usage=usage)
        parser.add_argument("-b", "--bar", action="store_true", dest="sbar",
                            help="display statusbar", default=self.sbar)
        parser.add_argument("-f", "--fullscreen", action="store_true",
                            dest="fullscreen", help="start in fullscreen",
                            default=self.fullscreen)
        parser.add_argument("-s", "--shuffle", action="store_true",
                            dest="shuffle", help="shuffle filelist",
                            default=self.shuffle)
        parser.add_argument("-S", "--no-shuffle", action="store_false",
                            dest="shuffle", help="don't shuffle the filelist")
        parser.add_argument("-r", "--recursive", action="store_true",
                            dest="recursive",
                            help="search given directories recursively",
                            default=self.recursive)
        parser.add_argument("--slideshow-delay", type=int,
                            help="set the slideshow delay",
                            default=self.slideshow_delay)
        parser.add_argument("-g", "--geomtry", dest="geometry",
                            help="set the starting geometry",
                            default=self.geometry)
        self.files = self.filelist_create()
        parser.add_argument("path", nargs='*', default=self.files)
        args = parser.parse_args()
        self.sbar = args.sbar
        self.recursive = args.recursive
        self.fullscreen = args.fullscreen
        self.shuffle = args.shuffle
        self.slideshow_delay = args.slideshow_delay
        self.geometry = args.geometry

        self.populate(args.path)

    def populate(self, args):
        ''' Generate a list of paths from the given arguments '''

        # get supported mimetypes
        types = []
        for pixbuf_format in GdkPixbuf.Pixbuf.get_formats():
            types.extend(pixbuf_format.get_mime_types())

        # If only one path is passed do special stuff
        single = None
        if len(args) == 1:
            arg = args[0]
            if os.path.isfile(arg):
                # use parent directory
                single = os.path.abspath(arg)
                directory = os.path.dirname(single)
                args = self.filelist_create(directory)

        # add everything
        for arg in args:
            path = os.path.abspath(arg)
            if os.path.isfile(path):
                self.paths.append(path)
            elif os.path.isdir(path) and self.recursive:
                paths = sorted(
                    [os.path.join(path, x)
                     for x in os.listdir(path)])
                self.paths.extend(paths)

        # remove unsupported files
        self.paths = [
            possible_path
            for possible_path in self.paths
            if mimetypes.guess_type(possible_path)[0] in types]

        # shuffle
        if self.shuffle:
            shuffle(self.paths)

        # complete special stuff for single arg
        if single and single in self.paths:
            self.index = self.paths.index(single)
        else:
            self.index = 0

        return len(self.paths)

    def mark(self):
        if self.paths[self.index] in self.marked:
            self.marked.remove(self.paths[self.index])
        else:
            self.marked.append(self.paths[self.index])
        self.update_info()

    def handle_key_press(self, widget, event):
        keyval = event.keyval
        keyname = Gdk.keyval_name(keyval)
        if keyval == Gdk.KEY_Shift_L or keyval == Gdk.KEY_Shift_R:
            return
        elif keyval == Gdk.KEY_Alt_L or keyval == Gdk.KEY_Alt_R:
            return
        elif keyval == Gdk.KEY_Control_L or keyval == Gdk.KEY_Control_R:
            return
        # Check for Control (^) or Mod1 (Alt)
        if event.get_state() & Gdk.ModifierType.CONTROL_MASK:
            keyname = '^{}'.format(keyname)
        if event.get_state() & Gdk.ModifierType.MOD1_MASK:
            keyname = 'Alt+{}'.format(keyname)
        # Loop through binds until found (Calls for improvements)
        for bind in self.binds:
            if keyname == bind[0]:
                funk = bind[1]
                args = bind[2:]
                funk(*args)
                return

    def library(self):
        self.libwin = Gtk.Window()
        self.libwin.set_title("Image Library Browser")
        self.libwin.set_border_width(5)
        self.libwin.set_default_size(300, 600)
        self.libwin.set_role("pop-up")
        self.libwin.set_icon_name("image-x-generic")

        # Set up the grid in which the file info will be positioned
        grid = Gtk.Grid()
        grid.set_column_homogeneous(True)
        grid.set_row_homogeneous(True)
        self.libwin.add(grid)
        # Entering content
        self.scrollable_treelist = Gtk.ScrolledWindow()
        self.scrollable_treelist.set_vexpand(True)
        grid.attach(self.scrollable_treelist, 0, 0, 8, 10)
        # Call the function to create the treeview
        self.treeview_create()
        self.scrollable_treelist.add(self.treeview)
        # Show it
        self.libwin.show_all()
        self.library_toggled = True

    def library_toggle(self):
        if self.library_toggled:
            self.library_toggled = False
            self.libwin.destroy()
        else:
            self.library()

    def treeview_create(self):
        # Tree View
        current_file_filter = self.filestore(self.datalist_create())
        self.treeview = Gtk.TreeView.new_with_model(current_file_filter)
        self.treepos = 0  # Needed for the movement keys
        # Select file when row activated
        self.treeview.connect("row-activated", self.file_select)
        # Handle key events
        self.treeview.add_events(Gdk.EventMask.KEY_PRESS_MASK |
                                 Gdk.EventMask.POINTER_MOTION_MASK)
        self.treeview.connect("key_press_event", self.handle_key_press)
        # Add the columns
        for i, name in enumerate(["Num", "Name", "Size"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(name, renderer, text=i)
            self.treeview.append_column(column)

    def filestore(self, datalist):
        # Filelist in a liststore model
        self.filelist = Gtk.ListStore(int, str, str)
        count = 0
        for data in datalist:
            data.insert(0, count)
            self.filelist.append(data)
            count += 1

        current_file_filter = self.filelist.filter_new()
        return current_file_filter

    def file_select(self, alternative, count, b):
        """ Selects the file from the treeview and does the correct thing
            namely focus image or go to directory """
        # Alternative comes from hjkl version
        try:
            int(alternative)
            count = alternative
        except:
            count = count.get_indices()[0]
        fil = self.files[count]
        if os.path.isdir(fil):
            self.move_up(fil)
        else:
            self.paths = []
            self.populate(self.files)
            self.move_index(count)
            self.library_toggle()

    def move_up(self, dir=".."):
        try:
            os.chdir(dir)
        except:
            err = "Error: directory not accessible"
            self.err_message(9, err)
        try:
            self.reload()
        except:
            self.library_toggle()

    def filelist_create(self, dir="."):
        p = Popen(['ls', dir], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        self.files, err = p.communicate()
        self.files = self.files.decode(encoding='UTF-8')
        self.files = self.files.split("\n")
        self.files.pop()
        return self.files

    def datalist_create(self):
        self.datalist = list()
        # supported types
        types = []  # for directories
        for pixbuf_format in GdkPixbuf.Pixbuf.get_formats():
            types.extend(pixbuf_format.get_mime_types())
        # remove unsupported files
        self.filelist_create()
        self.files = [
            possible_file
            for possible_file in self.files
            if mimetypes.guess_type(possible_file)[0] in types
            or os.path.isdir(possible_file)]
        for fil in self.files:
            p = Popen(['du', '-h', fil], stdin=PIPE, stdout=PIPE, stderr=PIPE)
            size, err = p.communicate()
            size = size.decode(encoding='UTF-8')
            size = size.split()[0]
            self.datalist.append([fil, size])

        return self.datalist

    def reload(self):
        if not self.library_toggled:
            raise ValueError
        self.scrollable_treelist.remove(self.treeview)
        self.treeview_create()
        self.scrollable_treelist.add(self.treeview)
        self.treeview.grab_focus()
        self.libwin.show_all()

    def auto_resize(self, w):
        if self.win.get_size() != self.size and self.paths:
            self.zoom_to(0)
            self.size = self.win.get_size()

    def main(self):

        self.parse_args()
        # Create vimiv directory if it doesn't exist
        vimivdir = os.path.join(os.path.expanduser("~"), ".vimiv")
        if not os.path.isdir(vimivdir):
            os.mkdir(vimivdir)

        # Screen
        screen = Gdk.Screen()
        self.Sizes = {}
        self.Sizes['sWidth'] = screen.width()
        self.Sizes['sHeight'] = screen.height()

        # Gtk window with keybindings
        self.win = Gtk.Window()
        self.win.add_events(Gdk.EventMask.KEY_PRESS_MASK |
                            Gdk.EventMask.POINTER_MOTION_MASK)
        self.win.connect('destroy', Gtk.main_quit)
        self.win.connect("key_press_event", self.handle_key_press)
        self.win.connect("check-resize", self.auto_resize)
        self.win.set_icon_name("image-x-generic")

        # Box in which everything gets packed
        self.vbox = Gtk.VBox()
        self.win.add(self.vbox)
        # Scrollable window in there
        self.scrolled_win = Gtk.ScrolledWindow()
        self.vbox.pack_start(self.scrolled_win, True, True, 0)

        # Viewport
        self.viewport = Gtk.Viewport()
        self.viewport.modify_bg(
            Gtk.StateType.NORMAL,
            Gdk.color_parse('#2C2C2C'))
        self.viewport.set_shadow_type(Gtk.ShadowType.NONE)
        self.scrolled_win.add(self.viewport)

        self.set_default_window_size()
        self.Sizes['wSize'] = self.win.get_size()
        self.image = Gtk.Image()
        self.viewport.add(self.image)

        self.statusbar = Gtk.Statusbar()
        self.vbox.pack_end(self.statusbar, False, False, 0)

        # Show images, if a path was given
        if len(self.paths) > 0:
            self.move_index(0)
            self.win.show_all()
            self.toggle_statusbar()
            if self.fullscreen:
                self.win.fullscreen()
        else:
            self.win.show_all()
            self.statusbar.push(10, "No valid paths, opening library viewer")
            self.timer_id = GLib.timeout_add_seconds(2, self.statusbar.pop, 10)
            self.timer_id = GLib.timeout_add_seconds(2, self.toggle_statusbar)
            self.timer_id = GLib.timeout_add(300, self.library_toggle)

        # Finally show the main window
        Gtk.main()


if __name__ == '__main__':

    Vimiv().main()
